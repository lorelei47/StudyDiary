## 引用类型

#### Object类型

```js
//定义
var test = {};
与
var test = new Object();
相同
//取值
在Object对象中取值有两种形式
1) person.name
2) person["name"] //这些方括号里面要以字符串形式表示
```



#### Array类型

> Array类型每个元素不一定时同一个类型，第一个为String，第二个可以为Number

```js
//定义
var Ay = new Array();//new 可以省略
var Ay = new Array(3);//长度为3的数组
var Ay = new Array("test");//含有一个元素的数组
```

> 检测数组

```js
var Ay = new Array();
if(Array.isArray(Ay)){ //判断是否为数组
    //操作
}
```

> 转换方法

```
具有对象拥有的方法：toLocaleString()、toString()、valueOf()
```

> 栈方法

```
栈数据结构访问方式是后进先出。
栈操作
push():推入/插入。可以接受一次推n个，此时数组长度+n
pop():移除/弹出。移除末尾最后一个，此时数组长度-1
```

> 队列方法

```
队列数据结构访问方式是先进先出。
队列操作
shift():取得前端第一个,此时数组长度-1
push():向数值末端推入一个，此时数组长度+1
unshift():从前端推入n个，此时长度+n
```

> 重排序方法

```
reverse():反转数组顺序
sort():升序排序。
//注意，sort()是将数组每个项toString()后，根据String类型来排序，因此，[1,5,15]通过sort()后会得到[1,15,5]。
因此，一般对数字类型的排序需要借助给sort()传入一个比较函数
```

```js
function compare(data1,data2){
    if(data1<data2){
       return -1;
       }else if (data1>data2){
           return 1;
       }else{
           return 0;
       }     
}
var Ay = [0,1,5,10,15];
Ay.sort(compare);
console.log(Ay);//0,1,5,10,15
//将compare比较条件反过来可以修改成倒序的比较函数
```

```
排序函数reverse()和sort()的返回值是返回排序后的数组
```

> 操作方法

```
concat():Ay.concat()在Ay基础上创建一个新的数组(增量式)
slice():同上，但是是减量式创建新数组，类似于截取。
splice():强大的数组操作方法。
	1) 删除：Ay.splice(0,2) //删除前两项
	2) 插入：splice(2,0,"1","2")从2位置插入两项，第二个参数是要删除的项。
	3) 替换：splice(2,1,"1","2")删除2位置项，再从2位置插入两项
```

> 位置方法

```
indexOf():从0位开始查找，返回第一个找到匹配项的位置
lastIndexOf():从末位开始查找，返回第一个找到匹配项的位置
第一个参数是查找的项，第二个参数(可选)是查找开始的位置(默认从最开始位置)
```

> 迭代方法

```
every():判断每项是否满足(某条件)，如果都满足则返回true。类似与操作
some():判断每项是否满足(某条件)，如果有一项满足则返回true。类似或操作
filter():过滤满足条件的项，组成一个新数组(由原数组项组成)。
forEach():没有返回，单纯遍历每项然后在传入的方法体内执行一些操作。类似for-in操作
map():返回的每项是由旧数组每项与传入函数运行得到的结果组成的新数组

```

> 归并方法

```
reduce():从左边迭代数组每个项，返回新值
reduceRight():从右边迭代数组每个项，返回新值
```

```js
//reduce()求和
//接受函数里面的参数：前一个值，当前值，项的索引，数组对象。
//注意：prev和cur都是回调函数的值，不是数组项。回调函数每次返回的值都会传入下一次迭代过程的prev
var Ay = [1,2,3,4,5]
var sum = Ay.reduce(function(prev,cur,index,array){
    return prev + cur;
})
console.log(sum)//15
//reduceRight()同理reduce，只不过是从最后一位开始遍历
```



#### Date类型

> 创建日期对象

```js
var date = new Date();//创建当前时间
//Date.UTC()和Date.parse()，格式化日期方法，但必须是都能表示日期的字符串，否则会返回NaN
```

> 继承的方法

```
与其他类型同理，继承了toString等方法。
```

> 日期格式化方法

```
提供了一些格式化日期成字符串的方法
toDateString()
toTimeString()
toLocaleDateString()
toLocaleTimeString()
toUTCString()
```

> 日期/时间组件方法(太多了，不列出来，可以自己去查)



#### RegExp类型

> RegExp类型创建正则表达式

```
格式
var expresssion = / pattern / flags;
flags使用有三个
g:全局匹配，不加的情况下，传进来的字符串匹配到第一个时就会停止。
i:不区分大小写匹配
m:表是匹配多行
//例如
/*
 * 匹配字符串所有at
 */
var =pat = /at/g;
```

> RegExp实例

```
每个实例都具有以下属性
global:布尔值 ，是否开启g
ignoreCase:布尔值 ，是否开启i
lastIndex:整数 ，匹配字符串的位置索引
multiline:布尔值，是否开启m
source:正则表达式
```

> RegExp实例方法

```
exec()
//接受一个参数，待匹配的字符串
//返回匹配结果数组
test()
//接受一个参数，待匹配的字符串
//返回true or false。即是否符合正则表达式
```

> RegExp构造函数属性

> 模式的局限性



#### Function类型

> 函数也是一种对象

```
//创建Function
function num(num1,num2)
等价于
var sum = function(num1,num2)
//函数名实则为指针
var numo = num; //可以给numo传参数，numo指向了函数num
```

> 没有重载

```
通过上述定义函数方式可以看出
当定义两个函数名一样的function(num1,num2)时。实则时将第二个定义得函数覆盖到第一个函数名变量上
var sum = function(num1,num2)
sum = function(num1,num2)
```

> 函数声明与函数表达式

```
js解析器在执行环境中加载数据(解析js代码)时，会优先读取函数声明，再读取函数调用。
这也就是为什么函数定义可以放在调用的后面原因。
//注意，当使用表达式方式定义函数时，则会报错
console.log(num);
var num = function(num1,num2)
这是因为var num是一个位于初始化的语句，而不是一个函数声明
```

> 作为值的函数

```
函数名本身就是变量，因此可以将函数名作为参数传到另一个函数里面
如：
function callSomeFunction(someFunction, someArgument){ 
 return someFunction(someArgument); 
}
function add10(num){
	return num+10;
}
var result = callSomeFunction(add10,10)//20
//如果改成callSomeFunction为
callSomeFunction(num){
	return someFunction(num)
}
//则这个someFunction可以称为闭包函数
```

> 函数的内部属性

```js
//函数内部有两个特色对象：arguments和this

//arguments是一种类数组对象，可以通过这个arguments[]来访问函数的参数，这也是函数定义时形参不是必要的原因。
//arguments有一个属性叫callee,是个指针，执行arguments对象的函数。
//像一些递归函数，如阶乘函数
function factorial(num){
	if(num<=1){
        return 1
    }else{
        return num*factorial(num-1)
    }
}
//函数内部使用了跟函数名一样的名字，这样会使得执行函数与这个factorial耦合在一起，如果这个时候
var func1 = factorial
factorial = function(){
    return 1;
}
//那么fun1就会失去了阶乘的功能
//因此我们可以将factorial函数改写成
function factorial(num){
	if(num<=1){
        return 1
    }else{
        return num*arguments.callee(num-1)
    }
}
//这样就可以降低阶乘函数与factorial名字的耦合性

//this(this的详细理解会单独放在一个模块下)
//this引用的是函数据以执行的环境对象，比如说在网页的全局域调用函数，那么this就引用window

```

> 函数属性和方法

```
每个函数都包括了两个属性：length和prototype
length:函数接收命名参数(形参)的个数
prototype:难点,极其重要(后续会重新讲解，先留空) --tudo
```

> 基本包装类型

```
基本类型值像String、Number、Boolean都不是引用类型，也就不是对象。没有相应的的属性和方法。
但为了能操作这三类，因此包装了String、Number、Boolean这三个特殊的引用类型
```

```
Boolean类型：布尔类型的引用类型对象是new Boolean()
Number类型：Number类型的引用类型对象是new Number()
String类型：String类型的引用类型对象是new String()
```





> 单体内置对象

